#!/bin/bash
# Enclii Pre-commit Hook - Secret Scanning & Lint Validation
# Prevents accidental commit of secrets, API keys, credentials, and lint errors

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üîç Running pre-commit validations...${NC}"

# Get list of staged files (excluding deleted files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}‚úì No staged files to check${NC}"
    exit 0
fi

# Patterns to detect secrets (each pattern on its own line for readability)
SECRET_PATTERNS=(
    # API Keys
    'sk-ant-[a-zA-Z0-9_-]{20,}'                    # Anthropic API keys
    'ghp_[a-zA-Z0-9]{36}'                          # GitHub Personal Access Tokens
    'gho_[a-zA-Z0-9]{36}'                          # GitHub OAuth tokens
    'github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}'   # GitHub Fine-grained tokens
    'AKIA[0-9A-Z]{16}'                             # AWS Access Key IDs
    'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24}'  # Slack tokens

    # Database URLs with passwords
    'postgres://[^:]+:[^@]+@'                      # PostgreSQL URLs with credentials
    'mysql://[^:]+:[^@]+@'                         # MySQL URLs with credentials
    'mongodb(\+srv)?://[^:]+:[^@]+@'              # MongoDB URLs with credentials
    'redis://:[^@]+@'                              # Redis URLs with password

    # Private keys
    'BEGIN RSA PRIVATE KEY'
    'BEGIN DSA PRIVATE KEY'
    'BEGIN EC PRIVATE KEY'
    'BEGIN OPENSSH PRIVATE KEY'
    'BEGIN PGP PRIVATE KEY'

    # Generic secrets (with context to reduce false positives)
    'password\s*[:=]\s*["\047][^"\047]{8,}'       # password = "value" or password: "value"
    'secret\s*[:=]\s*["\047][^"\047]{8,}'         # secret = "value"
    'api[_-]?key\s*[:=]\s*["\047][^"\047]{8,}'    # api_key = "value"
    'auth[_-]?token\s*[:=]\s*["\047][^"\047]{8,}' # auth_token = "value"

    # JWT secrets (base64 encoded, typically long)
    'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*'  # JWT tokens
)

# Files to exclude from scanning
EXCLUDE_PATTERNS=(
    '\.md$'
    '\.sample$'
    'test.*\.go$'
    '_test\.go$'
    'mock.*\.go$'
    '\.example$'
    'CLAUDE\.md$'
    'go\.sum$'
    'go\.mod$'
    'package-lock\.json$'
    'yarn\.lock$'
    'pnpm-lock\.yaml$'
    'scripts/hooks/pre-commit$'
    '\.pre-commit-config\.yaml$'
    '\.git/hooks/pre-commit$'
)

# Build exclude pattern for grep
EXCLUDE_ARGS=""
for pattern in "${EXCLUDE_PATTERNS[@]}"; do
    EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude-pattern=$pattern"
done

FOUND_SECRETS=0
FINDINGS=""

for file in $STAGED_FILES; do
    # Skip if file doesn't exist (deleted)
    if [ ! -f "$file" ]; then
        continue
    fi

    # Skip excluded file types
    SKIP=0
    for exclude in "${EXCLUDE_PATTERNS[@]}"; do
        if echo "$file" | grep -qE "$exclude"; then
            SKIP=1
            break
        fi
    done

    if [ $SKIP -eq 1 ]; then
        continue
    fi

    # Check each pattern
    for pattern in "${SECRET_PATTERNS[@]}"; do
        MATCHES=$(git diff --cached --diff-filter=ACM -p "$file" 2>/dev/null | grep -nE "^\+" | grep -iE "$pattern" || true)
        if [ -n "$MATCHES" ]; then
            FOUND_SECRETS=1
            FINDINGS="$FINDINGS\n${RED}‚ö†Ô∏è  Potential secret in $file:${NC}\n"
            FINDINGS="$FINDINGS   Pattern: $pattern\n"
            # Show first 80 chars of match (truncated for security)
            MATCH_PREVIEW=$(echo "$MATCHES" | head -1 | cut -c1-80)
            FINDINGS="$FINDINGS   Match: ${MATCH_PREVIEW}...\n"
        fi
    done
done

if [ $FOUND_SECRETS -eq 1 ]; then
    echo -e "\n${RED}‚ùå SECRET DETECTED IN STAGED FILES${NC}"
    echo -e "$FINDINGS"
    echo -e "\n${YELLOW}If this is a false positive, you can:${NC}"
    echo -e "  1. Add the file to the exclude list in .git/hooks/pre-commit"
    echo -e "  2. Use 'git commit --no-verify' to bypass (not recommended)"
    echo -e "  3. Move the secret to environment variables or a secrets manager"
    echo -e "\n${YELLOW}For legitimate test data, ensure it's clearly marked as fake/development.${NC}"
    exit 1
fi

echo -e "${GREEN}‚úì No secrets detected in staged files${NC}"

# =============================================================================
# GOFMT AUTO-FORMATTING - Automatically fix Go formatting before commit
# =============================================================================

GO_FILES=$(echo "$STAGED_FILES" | grep -E '\.go$' || true)
if [ -n "$GO_FILES" ]; then
    echo -e "\n${BLUE}üîß Auto-formatting Go files...${NC}"
    FORMATTED_FILES=""

    for file in $GO_FILES; do
        if [ -f "$file" ]; then
            # Check if file needs formatting
            if ! gofmt -l "$file" | grep -q .; then
                continue  # Already formatted
            fi

            # Auto-format the file
            gofmt -w "$file"
            git add "$file"
            FORMATTED_FILES="$FORMATTED_FILES $file"
        fi
    done

    if [ -n "$FORMATTED_FILES" ]; then
        echo -e "${GREEN}  ‚úì Auto-formatted and staged:${NC}"
        for f in $FORMATTED_FILES; do
            echo -e "    - $f"
        done
    else
        echo -e "${GREEN}  ‚úì All Go files already formatted${NC}"
    fi
fi

# =============================================================================
# LINT VALIDATION - Catch errors before they reach CI
# =============================================================================

echo -e "\n${BLUE}üîß Running lint validations...${NC}"

# Check if any UI files are staged
UI_FILES=$(echo "$STAGED_FILES" | grep -E '^apps/switchyard-ui/.*\.(ts|tsx|js|jsx|mjs)$' || true)
if [ -n "$UI_FILES" ]; then
    echo -e "${YELLOW}  ‚Üí Checking switchyard-ui TypeScript...${NC}"
    if [ -f "apps/switchyard-ui/package.json" ]; then
        cd apps/switchyard-ui

        # Run TypeScript type checking first (catches type errors before ESLint)
        if npm run typecheck 2>&1 | grep -qE "error TS|Error:"; then
            echo -e "${RED}‚ùå TypeScript errors found in switchyard-ui${NC}"
            echo -e "${YELLOW}Run 'npm run typecheck' in apps/switchyard-ui to see details${NC}"
            cd ../..
            exit 1
        fi
        echo -e "${GREEN}  ‚úì switchyard-ui typecheck passed${NC}"

        # Then run ESLint
        echo -e "${YELLOW}  ‚Üí Checking switchyard-ui ESLint...${NC}"
        # Only run lint on staged files for speed, but check plugin availability first
        if ! npm run lint -- --quiet --max-warnings 0 2>&1 | head -20; then
            # If lint fails with errors, block commit
            if npm run lint 2>&1 | grep -qE "^Error:|error.*found"; then
                echo -e "${RED}‚ùå ESLint errors found in switchyard-ui${NC}"
                echo -e "${YELLOW}Run 'npm run lint' in apps/switchyard-ui to see details${NC}"
                cd ../..
                exit 1
            fi
        fi
        cd ../..
        echo -e "${GREEN}  ‚úì switchyard-ui lint passed${NC}"
    fi
fi

# Check if any Go files are staged
GO_FILES=$(echo "$STAGED_FILES" | grep -E '\.go$' || true)
if [ -n "$GO_FILES" ]; then
    echo -e "${YELLOW}  ‚Üí Checking Go lint...${NC}"
    # Check each Go module that has changes
    for module in apps/switchyard-api apps/roundhouse apps/waybill packages/cli; do
        if echo "$GO_FILES" | grep -q "^$module/"; then
            if [ -f "$module/go.mod" ]; then
                echo -e "${YELLOW}    ‚Üí Linting $module...${NC}"
                cd "$module"
                if command -v golangci-lint &> /dev/null; then
                    if ! golangci-lint run --timeout=2m ./... 2>&1 | head -20; then
                        echo -e "${RED}‚ùå golangci-lint errors in $module${NC}"
                        cd ../..
                        exit 1
                    fi
                else
                    echo -e "${YELLOW}    ‚ö† golangci-lint not installed, skipping Go lint${NC}"
                fi
                cd - > /dev/null
            fi
        fi
    done
    echo -e "${GREEN}  ‚úì Go lint passed${NC}"
fi

# =============================================================================
# FILE LENGTH VALIDATION - Prevent large files from growing
# =============================================================================

echo -e "\n${BLUE}üìè Checking file lengths...${NC}"

FILE_LENGTH_ERRORS=0
FILE_LENGTH_WARNINGS=0
ERROR_FILES=""
WARNING_FILES=""

for file in $STAGED_FILES; do
    # Skip non-source files
    if ! echo "$file" | grep -qE '\.(go|ts|tsx|js|jsx|py)$'; then
        continue
    fi

    # Skip test files (more lenient)
    if echo "$file" | grep -qE '(_test\.go|\.test\.(ts|tsx|js)|\.spec\.(ts|tsx|js)|/tests?/)'; then
        continue
    fi

    # Skip generated files
    if echo "$file" | grep -qE '(generated|\.gen\.|mock_)'; then
        continue
    fi

    if [ -f "$file" ]; then
        LINES=$(wc -l < "$file" | tr -d ' ')

        if [ "$LINES" -gt 800 ]; then
            FILE_LENGTH_ERRORS=1
            ERROR_FILES="$ERROR_FILES\n  ${RED}‚ùå $file: $LINES lines (>800)${NC}"
        elif [ "$LINES" -gt 600 ]; then
            FILE_LENGTH_WARNINGS=1
            WARNING_FILES="$WARNING_FILES\n  ${YELLOW}‚ö†Ô∏è  $file: $LINES lines (>600)${NC}"
        fi
    fi
done

if [ -n "$ERROR_FILES" ]; then
    echo -e "${RED}Files exceeding 800 lines:${NC}$ERROR_FILES"
fi

if [ -n "$WARNING_FILES" ]; then
    echo -e "${YELLOW}Files exceeding 600 lines (warning):${NC}$WARNING_FILES"
fi

if [ $FILE_LENGTH_ERRORS -eq 1 ]; then
    echo -e "\n${RED}‚ùå FILE LENGTH ERROR: Files over 800 lines must be refactored${NC}"
    echo -e "${YELLOW}Suggestions:${NC}"
    echo -e "  - Split into smaller focused modules"
    echo -e "  - Extract helper functions to separate files"
    echo -e "  - Move types to dedicated type files"
    echo -e "  - Use 'git commit --no-verify' to bypass (not recommended)"
    exit 1
fi

if [ $FILE_LENGTH_WARNINGS -eq 1 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Warning: Consider refactoring files approaching 800 lines${NC}"
fi

echo -e "${GREEN}‚úì File length check passed${NC}"

# =============================================================================
# OPERATION RATCHET - Manifest Stability Validation
# =============================================================================

# Check if any critical manifest files are staged
MANIFEST_FILES=$(echo "$STAGED_FILES" | grep -E '(infra/k8s/|apps/.*/k8s/|\.github/workflows/)' || true)
if [ -n "$MANIFEST_FILES" ]; then
    echo -e "\n${BLUE}üîí Running Operation Ratchet validation...${NC}"

    # Run manifest audit (quick check for critical config keys)
    if [ -x "./scripts/validate.sh" ]; then
        echo -e "${YELLOW}  ‚Üí Checking manifest critical keys...${NC}"
        # Run in quick mode to avoid slow build checks
        if ! ./scripts/validate.sh 2>&1 | grep -E "(MISSING|FAILED)" > /dev/null; then
            echo -e "${GREEN}  ‚úì Manifest audit passed${NC}"
        else
            echo -e "${RED}‚ùå Operation Ratchet: Critical config keys missing!${NC}"
            echo -e "${YELLOW}Run './scripts/validate.sh' to see details${NC}"
            exit 1
        fi
    fi

    # Run golden config check if golden configs exist
    if [ -x "./scripts/check-golden.sh" ] && [ -d "tests/golden/k8s" ]; then
        echo -e "${YELLOW}  ‚Üí Checking golden config drift...${NC}"
        if ./scripts/check-golden.sh > /dev/null 2>&1; then
            echo -e "${GREEN}  ‚úì Golden config check passed${NC}"
        else
            echo -e "${RED}‚ùå Operation Ratchet: Golden config drift detected!${NC}"
            echo -e "${YELLOW}Run './scripts/check-golden.sh' to see diffs${NC}"
            echo -e "${YELLOW}If changes are intentional, run './scripts/update-golden.sh'${NC}"
            exit 1
        fi
    fi
fi

echo -e "\n${GREEN}‚úÖ All pre-commit validations passed${NC}"
exit 0
